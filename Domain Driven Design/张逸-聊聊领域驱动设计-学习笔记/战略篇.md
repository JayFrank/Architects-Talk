# 访谈录 | 聊聊领域驱动设计（文字版）
**注意：本文是对于张逸的访谈，因此文章中的“我”都是指的是张逸。**

> 在这部分，张逸谈到了关于DDD的未来两个趋势。

我个人认为，未来 DDD 的发展可能会出现以下趋势：
* 以函数式编程思想为基础的领域建模理念与事件驱动架构和响应式编程的结合，可能在低延迟高并发的项目中发挥作用。这种领域驱动设计思想已经比较成熟，但目前还没有看到太多成功的运用。
* 以 DDD 设计方法为基础的框架的出现，让微服务设计与领域建模变得更加容易，降低领域驱动设计的门槛。

领域驱动设计并不是一套死板的方法，而是一种设计思想、一种开放的设计方法体系，只要有利于领域驱动设计的实践，都可以引入其中。

> 张逸讲了一个他和《实现领域驱动设计》作者 Vaughn Vernon之间的故事。

我在 ThoughtWorks 的时候，公司邀请《实现领域驱动设计》作者 Vaughn Vernon 到北京 Office 给我们做了一次 DDD 培训。借着这次亲炙大师教诲的机会，我向他请教了一个一直缠绕在我心中困惑不解的问题：“如何正确地识别限界上下文？”结果他思考了一会儿，严肃地回答了我：“By experience！” 我唯有无言以对。

# 开篇词 | 领域驱动设计，重焕青春的设计经典
**领域驱动设计是一个开放的设计方法体系**

> 张逸对于为什么要学习领域驱动设计的几个观点：

如果你已经能设计出美丽优良的软件架构，如果你只希望脚踏实地做一名高效编码的程序员，如果你是一位注重用户体验的前端设计人员，如果你负责的软件系统并不复杂，那么，你确实不需要学习领域驱动设计！

领域驱动设计当然并非“银弹”，自然也不是解决所有疑难杂症的“灵丹妙药”，请事先降低对领域驱动设计的不合现实的期望。我以中肯地态度总结了领域驱动设计可能会给你带来的收获：

* 领域驱动设计是一套完整而系统的设计方法，它能带给你从战略设计到战术设计的规范过程，使得你的设计思路能够更加清晰，设计过程更加规范。
* 领域驱动设计尤其善于处理与领域相关的高复杂度业务的产品研发，通过它可以为你的产品建立一个核心而稳定的领域模型内核，有利于领域知识的传递与传承。
* 领域驱动设计强调团队与领域专家的合作，能够帮助团队建立一个沟通良好的团队组织，构建一致的架构体系。
* 领域驱动设计强调对架构与模型的精心打磨，尤其善于处理系统架构的演进设计。
* 领域驱动设计的思想、原则与模式有助于提高团队成员的面向对象设计能力与架构设计能力。
* 领域驱动设计与微服务架构天生匹配，无论是在新项目中设计微服务架构，还是将系统从单体架构演进到微服务设计，都可以遵循领域驱动设计的架构原则。

要掌握领域驱动设计，就不要被它给出的概念所迷惑，而要去思索这些概念背后蕴含的原理，多问一些为什么。同时，要学会运用设计原则去解决问题，而非所谓的“设计规范”。例如：

* 思考限界上下文边界的划分，实际上还是“高内聚、低耦合”原则的体现，只是我们需要考虑什么内容才是高内聚的，如何抽象才能做到低耦合？
* 是否需要提取单独的限界上下文？是为了考虑职责的重用，还是为了它能够独立进化以应对未来的变化？
* 在分层架构中，各层之间该如何协作？如果出现了依赖，该如何解耦？仍然需要从重用与变化的角度去思考设计决策。
* 为什么同样遵循领域驱动设计，不同的系统会设计出不同的架构？这是因为不同的场景对架构质量的要求并不一样，我们要学会对架构的关注点做优先级排列，从而得出不同的架构决策。

**学会对设计的本质思考，不要只限于对设计概念的掌握，而要追求对设计原则与方法的融汇贯通。**

# 第01课：领域驱动设计概览
领域驱动设计（Domain Driven Design，DDD）是由 Eric Evans 最早提出的综合软件系统分析和设计的面向对象建模方法，如今已经发展成为了一种针对大型复杂系统的领域建模与分析方法。它完全改变了传统软件开发工程师 **针对数据库进行的建模方法** ，从而 **将要解决的业务概念和业务规则转换为软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承和多态等设计要素** ，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题。

## 领域驱动设计的开放性
领域驱动设计的提出，是 **设计观念的转变，蕴含了全新的设计思想、设计原则与设计过程**。

由于领域驱动设计是一套方法论，它建立了 **以领域为核心驱动力** 的设计体系，因而具有一定的开放性。

## 领域驱动设计过程
> > 张逸谈到对于DDD的理解，那么DDD究竟是什么呢？

领域驱动设计当然不是架构方法，也并非设计模式。准确地说，它其实是 **“一种思维方式，也是一组优先任务，它旨在加速那些必须处理复杂领域的软件项目的开发”** 。领域驱动设计贯穿了整个软件开发的生命周期，包括对需求的分析、建模、架构、设计，甚至最终的编码实现，乃至对编码的测试与重构。

对于一个复杂的软件系统而言，我们要处理的问题域实在太庞大了。在为问题域寻求解决方案时，需要从宏观层次划分不同业务关注点的子领域，然后再深入到子领域中从微观层次对领域进行建模。

宏观层次是 **战略的层面** ，微观层次是 **战术的层面** ，只有将战略设计与战术设计结合起来，才是完整的领域驱动设计。

## 战略设计阶段
领域驱动设计的战略设计阶段是从下面两个方面来考量的：

* 问题域方面：针对问题域，引入**限界上下文（Bounded Context）** 和 **上下文映射（Context Map）** 对问题域进行合理的分解，识别出 **核心领域（Core Domain）** 与 **子领域（SubDomain）** ，并确定领域的边界以及它们之间的关系，维持模型的完整性。
* 架构方面：通过 **分层架构** 来隔离关注点，尤其是将领域实现独立出来，能够更利于领域模型的单一性与稳定性；引入 **六边形架构** 可以清晰地表达领域与技术基础设施的边界；CQRS 模式则分离了查询场景和命令场景，针对不同场景选择使用同步或异步操作，来提高架构的低延迟性与高并发能力。

Eric Evans 提出战略设计的初衷是要 **保持模型的完整性**。限界上下文的边界可以保护上下文内部和其他上下文之间的领域概念互不冲突。然而，如果我们将领域驱动设计的战略设计模式引入到架构过程中，就会发现限界上下文不仅限于对领域模型的控制，而在于分离关注点之后，使得整个上下文可以成为独立部署的设计单元，这就是“微服务”的概念，上下文映射的诸多模式则对应了微服务之间的协作。因此在战略设计阶段，微服务扩展了领域驱动设计的内容，反过来领域驱动设计又能够保证良好的微服务设计。

一旦确立了限界上下文的边界，尤其是作为物理边界，则分层架构就不再针对整个软件系统，而仅仅针对粒度更小的限界上下文。此时，限界上下文定义了技术实现的边界，对当前上下文的领域与技术实现进行了封装，我们只需要关心对外暴露的接口与集成方式，形成了在服务层次的设计单元重用。

边界给了实现限界上下文内部的最大自由度，这也是战略设计在 **分治** 上起到的效用，我们可以在不同的限界上下文选择不同的架构模式。在宏观层面，面对整个软件系统，我们可以采用前后端分离与基于 REST 的微服务架构，保证系统具有一致的架构风格。

## 战术设计阶段
整个软件系统被分解为多个限界上下文（或领域）后，就可以分而治之，对每个限界上下文进行战术设计。领域驱动设计并不牵涉到技术层面的实现细节，在战术层面，它主要应对的是领域的复杂性。领域驱动设计用以表示模型的主要要素包括：

* 值对象（Value Object）
* 实体（Entity）
* 领域服务（Domain Service）
* 领域事件（Domain Event）
* 资源库（Repository）
* 工厂（Factory）
* 聚合（Aggregate）
* 应用服务（Application Service）

Eric Evans 通过下图勾勒出了 **战术设计诸要素之间的关系** ：

<img src="https://github.com/JayFrank/Architects-Talk/blob/master/Domain%20Driven%20Design/%E5%BC%A0%E9%80%B8-%E8%81%8A%E8%81%8A%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Link/DDD-1-1.png"  height=“300">

领域驱动设计围绕着领域模型进行设计，通过 **分层架构（Layered Architecture）** 将领域独立出来。表示领域模型的对象包括：**实体** 、 **值对象** 和 **领域服务** ，**领域逻辑都应该封装在这些对象中**。这一严格的设计原则可以避免业务逻辑渗透到领域层之外，导致技术实现与业务逻辑的混淆。在领域驱动设计的演进中，又引入了 **领域事件** 来丰富领域模型。

 **聚合** 是一种边界，它可以封装一到多个 **实体** 与 **值对象** ，并维持该边界范围之内的业务完整性。在聚合中，至少包含一个实体，且只有实体才能作为 **聚合根（Aggregate Root）** 。注意，在领域驱动设计中，没有任何一个类是单独的聚合，因为聚合代表的是边界概念，而非领域概念。在极端情况下，一个聚合可能有且只有一个实体。

**工厂** 和 **资源库** 都是对领域对象生命周期的管理。前者负责领域对象的创建，往往用于封装复杂或者可能变化的创建逻辑；后者则负责从存放资源的位置（数据库、内存或者其他 Web 资源）获取、添加、删除或者修改领域对象。领域模型中的资源库不应该暴露访问领域对象的技术实现细节。



